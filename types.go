// @generated by Thrift for [[[ program path ]]]
// This file is probably not the place you want to edit!

package compat // [[[ program thrift source path ]]]

import (
    "fmt"
    "strings"

    thrift "thrift/lib/go/thrift"
)

// (needed to ensure safety because of naive import list construction)
var _ = fmt.Printf
var _ = strings.Split
var _ = thrift.ZERO


type CodingErrorAction int32

const (
    CodingErrorAction_Legacy CodingErrorAction = 0
    CodingErrorAction_Report CodingErrorAction = 1
)

// Enum value maps for CodingErrorAction
var (
    CodingErrorActionToName = map[CodingErrorAction]string {
        CodingErrorAction_Legacy: "Legacy",
        CodingErrorAction_Report: "Report",
    }

    CodingErrorActionToValue = map[string]CodingErrorAction {
        "Legacy": CodingErrorAction_Legacy,
        "Report": CodingErrorAction_Report,
    }
)

func (x CodingErrorAction) String() string {
    if v, ok := CodingErrorActionToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x CodingErrorAction) Ptr() *CodingErrorAction {
    return &x
}

// Deprecated: Use CodingErrorActionToValue instead (e.g. `x, ok := CodingErrorActionToValue["name"]`).
func CodingErrorActionFromString(s string) (CodingErrorAction, error) {
    if v, ok := CodingErrorActionToValue[s]; ok {
        return v, nil
    }
    return CodingErrorAction(0), fmt.Errorf("not a valid CodingErrorAction string")
}


type EnumType int32

const (
    EnumType_Legacy EnumType = 0
    EnumType_Open EnumType = 1
)

// Enum value maps for EnumType
var (
    EnumTypeToName = map[EnumType]string {
        EnumType_Legacy: "Legacy",
        EnumType_Open: "Open",
    }

    EnumTypeToValue = map[string]EnumType {
        "Legacy": EnumType_Legacy,
        "Open": EnumType_Open,
    }
)

func (x EnumType) String() string {
    if v, ok := EnumTypeToName[x]; ok {
        return v
    }
    return "<UNSET>"
}

func (x EnumType) Ptr() *EnumType {
    return &x
}

// Deprecated: Use EnumTypeToValue instead (e.g. `x, ok := EnumTypeToValue["name"]`).
func EnumTypeFromString(s string) (EnumType, error) {
    if v, ok := EnumTypeToValue[s]; ok {
        return v, nil
    }
    return EnumType(0), fmt.Errorf("not a valid EnumType string")
}


type Strings struct {
    OnInvalidUtf8 CodingErrorAction `thrift:"onInvalidUtf8,1" json:"onInvalidUtf8" db:"onInvalidUtf8"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Strings{}

func NewStrings() *Strings {
    return (&Strings{}).
        SetOnInvalidUtf8NonCompat(0)
}

func (x *Strings) GetOnInvalidUtf8NonCompat() CodingErrorAction {
    return x.OnInvalidUtf8
}

func (x *Strings) GetOnInvalidUtf8() CodingErrorAction {
    return x.OnInvalidUtf8
}

func (x *Strings) SetOnInvalidUtf8NonCompat(value CodingErrorAction) *Strings {
    x.OnInvalidUtf8 = value
    return x
}

func (x *Strings) SetOnInvalidUtf8(value CodingErrorAction) *Strings {
    x.OnInvalidUtf8 = value
    return x
}

func (x *Strings) writeField1(p thrift.Format) error {  // OnInvalidUtf8
    if err := p.WriteFieldBegin("onInvalidUtf8", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetOnInvalidUtf8NonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Strings) readField1(p thrift.Format) error {  // OnInvalidUtf8
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := CodingErrorAction(enumResult)

    x.SetOnInvalidUtf8NonCompat(result)
    return nil
}

func (x *Strings) toString1() string {  // OnInvalidUtf8
    return fmt.Sprintf("%v", x.GetOnInvalidUtf8NonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewStrings().Set<FieldNameFoo>().Set<FieldNameBar>()
type StringsBuilder struct {
    obj *Strings
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewStrings().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewStringsBuilder() *StringsBuilder {
    return &StringsBuilder{
        obj: NewStrings(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewStrings().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *StringsBuilder) OnInvalidUtf8(value CodingErrorAction) *StringsBuilder {
    x.obj.OnInvalidUtf8 = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewStrings().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *StringsBuilder) Emit() *Strings {
    var objCopy Strings = *x.obj
    return &objCopy
}

func (x *Strings) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("Strings"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Strings) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // onInvalidUtf8
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Strings) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Strings({")
    sb.WriteString(fmt.Sprintf("OnInvalidUtf8:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

type Utf8 struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &Utf8{}

func NewUtf8() *Utf8 {
    return (&Utf8{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewUtf8().Set<FieldNameFoo>().Set<FieldNameBar>()
type Utf8Builder struct {
    obj *Utf8
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewUtf8().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewUtf8Builder() *Utf8Builder {
    return &Utf8Builder{
        obj: NewUtf8(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewUtf8().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *Utf8Builder) Emit() *Utf8 {
    var objCopy Utf8 = *x.obj
    return &objCopy
}

func (x *Utf8) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("Utf8"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Utf8) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Utf8) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Utf8({")
    sb.WriteString("})")

    return sb.String()
}

type LegacyString struct {
}
// Compile time interface enforcer
var _ thrift.Struct = &LegacyString{}

func NewLegacyString() *LegacyString {
    return (&LegacyString{})
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewLegacyString().Set<FieldNameFoo>().Set<FieldNameBar>()
type LegacyStringBuilder struct {
    obj *LegacyString
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewLegacyString().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewLegacyStringBuilder() *LegacyStringBuilder {
    return &LegacyStringBuilder{
        obj: NewLegacyString(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewLegacyString().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *LegacyStringBuilder) Emit() *LegacyString {
    var objCopy LegacyString = *x.obj
    return &objCopy
}

func (x *LegacyString) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("LegacyString"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *LegacyString) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *LegacyString) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("LegacyString({")
    sb.WriteString("})")

    return sb.String()
}

type Enums struct {
    Type EnumType `thrift:"type,1" json:"type" db:"type"`
}
// Compile time interface enforcer
var _ thrift.Struct = &Enums{}

func NewEnums() *Enums {
    return (&Enums{}).
        SetTypeNonCompat(0)
}

func (x *Enums) GetTypeNonCompat() EnumType {
    return x.Type
}

func (x *Enums) GetType() EnumType {
    return x.Type
}

func (x *Enums) SetTypeNonCompat(value EnumType) *Enums {
    x.Type = value
    return x
}

func (x *Enums) SetType(value EnumType) *Enums {
    x.Type = value
    return x
}

func (x *Enums) writeField1(p thrift.Format) error {  // Type
    if err := p.WriteFieldBegin("type", thrift.I32, 1); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field begin error: ", x), err)
    }

    item := x.GetTypeNonCompat()
    if err := p.WriteI32(int32(item)); err != nil {
    return err
}

    if err := p.WriteFieldEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field end error: ", x), err)
    }
    return nil
}

func (x *Enums) readField1(p thrift.Format) error {  // Type
    enumResult, err := p.ReadI32()
if err != nil {
    return err
}
result := EnumType(enumResult)

    x.SetTypeNonCompat(result)
    return nil
}

func (x *Enums) toString1() string {  // Type
    return fmt.Sprintf("%v", x.GetTypeNonCompat())
}


// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnums().Set<FieldNameFoo>().Set<FieldNameBar>()
type EnumsBuilder struct {
    obj *Enums
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnums().Set<FieldNameFoo>().Set<FieldNameBar>()
func NewEnumsBuilder() *EnumsBuilder {
    return &EnumsBuilder{
        obj: NewEnums(),
    }
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnums().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *EnumsBuilder) Type(value EnumType) *EnumsBuilder {
    x.obj.Type = value
    return x
}

// Deprecated: Use "New" constructor and setters to build your structs.
// e.g NewEnums().Set<FieldNameFoo>().Set<FieldNameBar>()
func (x *EnumsBuilder) Emit() *Enums {
    var objCopy Enums = *x.obj
    return &objCopy
}

func (x *Enums) Write(p thrift.Format) error {
    if err := p.WriteStructBegin("Enums"); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", x), err)
    }

    if err := x.writeField1(p); err != nil {
        return err
    }

    if err := p.WriteFieldStop(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write field stop error: ", x), err)
    }

    if err := p.WriteStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T write struct end error: ", x), err)
    }
    return nil
}

func (x *Enums) Read(p thrift.Format) error {
    if _, err := p.ReadStructBegin(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read error: ", x), err)
    }

    for {
        _, wireType, id, err := p.ReadFieldBegin()
        if err != nil {
            return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", x, id), err)
        }

        if wireType == thrift.STOP {
            break;
        }

        switch {
        case (id == 1 && wireType == thrift.Type(thrift.I32)):  // type
            if err := x.readField1(p); err != nil {
                return err
            }
        default:
            if err := p.Skip(wireType); err != nil {
                return err
            }
        }

        if err := p.ReadFieldEnd(); err != nil {
            return err
        }
    }

    if err := p.ReadStructEnd(); err != nil {
        return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", x), err)
    }

    return nil
}

func (x *Enums) String() string {
    if x == nil {
        return "<nil>"
    }

    var sb strings.Builder

    sb.WriteString("Enums({")
    sb.WriteString(fmt.Sprintf("Type:%s", x.toString1()))
    sb.WriteString("})")

    return sb.String()
}

// RegisterTypes registers types found in this file that have a thrift_uri with the passed in registry.
func RegisterTypes(registry interface {
  RegisterType(name string, initializer func() any)
}) {
    registry.RegisterType("example.com/thrift/annotation/Strings", func() any { return NewStrings() })
    registry.RegisterType("example.com/thrift/annotation/Utf8", func() any { return NewUtf8() })
    registry.RegisterType("example.com/thrift/annotation/LegacyString", func() any { return NewLegacyString() })
    registry.RegisterType("example.com/thrift/annotation/Enums", func() any { return NewEnums() })

    registry.RegisterType("example.com/thrift/annotation/CodingErrorAction", func() any { return CodingErrorAction(0) })
    registry.RegisterType("example.com/thrift/annotation/EnumType", func() any { return EnumType(0) })
}
